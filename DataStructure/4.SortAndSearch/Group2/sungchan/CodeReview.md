# 코드 리뷰

###### <span style ="color : skyblue;">모든 리뷰는 c/c++ 코드를 바탕으로 작성되었습니다.

## 1092 - 배

이 문제는 되게 까다로웠다. 문제에 필요했던 발상은 오름차순이 아닌 greater<int>() 를 이용해 내림차순으로 정렬을 해서 무거운 것부터 처리하는 방식을 이용해야한다. 

또한 이를 알아차린다고 해도 구현하는 방식도 예외처리르 해야할 상황도 말끔하게 나오지가 않는다. 

```
#include <bits/stdc++.h>
using namespace std;
int main(void)
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n; cin >> n; int count = 0;
    vector<int> vc1(n);
    for(int i = 0; i < n; i++)
        cin >> vc1[i];
    int m; cin >> m;;
    vector<int> vc2(m);
    for(int i = 0; i < m; i++)
        cin >> vc2[i];
    sort(vc1.begin(), vc1.end(), greater<int>());
    sort(vc2.begin(), vc2.end(), greater<int>());
    if(vc1[0] < vc2[0]) cout << "-1\n";

    else
    {
        while(!vc2.empty())
        {
            for(int i = 0; i < n; i++)
            {
                for(int j = 0; j < m; j++)
                {
                    if(vc1[i] >= vc2[j])
                    {
                        vc2.erase(vc2.begin() + j); m--;
                        break;
                    }

                    else{
                        count += 1;
                        i = 0;
                        break;
                    }
                }
                if(i == (n-1)) count++;
            }
        }
        cout << count << '\n';
    }
    return 0;
}
```

이게 내가 구현했던 코드였는데, 결국 반례가 존재하고 이를 바탕으로 여러가지를 시도해봐도 최종 답안을 얻을 수 없었고 검색을 힘을 빌려 코드를 수정했다. 문제가 됐던 부분은 이중 for문에서 발생했다.  

이 문제를 통해 얻은 것은 여사건을 바탕으로 생각하면 복잡했던 경우들을 좀 더 쉬운 방식으로 접근할 수 있게 된다. 또한 예외처리를 할 때 좀 더 효율적인 방식이 없는지 넓게 생각하는 습관을 길러야 할 것 같다.

## 2002 - 추월

이 문제가 개인적으로 가장 오래 걸렸던 문제였다. 문제를 이해하는 과정은 매우 단순하지만 이에 대한 반례가 너무 많이 발생했고, 이러한 아이디어를 떠올리는게 굉장히 쉽지 않았다.

많은 시간을 고민한 끝에 입력된 순서를 매기는 DFS문제의 방식이 떠올랐다. 어떠한 값에 i의 입력된 순서를 매기는 방식으로 진행을 한 후에 그저 그 입력된 순서의 값이 역순으로 돼있으면 추월이 됐다고 판단을 하면된다.

또한 c++ 에서의 map은 파이썬의 딕셔너리와 다르게 자동정렬되는 특성을 가지고 있는데, 이 문제는 정렬이 되는 것보다 들어오는 순서를 체크하는 것이 더 중요하기 때문에 "unordered_map"을 이용해 파이썬의 딕셔너리처럼 이용하는 것이 Key point이다.

## 2512 - 예산

이 문제는 시간복잡도가 매우 중요하기 때문에 총 4번의 시도 끝에 문제를 풀었다. O(N^2)의 시간복잡도는 모두 틀렸다고 처리되기 때문에 어떻게 하면 O(N)의 시간복잡도로 풀 수 있는지 방안을 생각해야내야한다. 지속적으로 범위를 조정하면서 상한액을 체크해야되기 때문에 기존에 for문을 이용하면 find는 사용하면 안된다. find자체가 O(n)에 시간복잡도를 가지기 때문에 for문하고 결합되면 복잡도가 초과된다.

이를 해결하기 위해서는 이진탐색을 이용해서 O(log n)의 시간복잡도가 나오게끔 코드를 유도해야한다.

이진탐색에서 중요한 점은 꼭 sort된 배열이나 벡터를 사용해야하고, mid값을 정할 때 이 문제는 크게 중요하지 않지만 오버플로우가 발생할 수 있기 때문에 mid = (low + high) / 2 보다는 mid = low + (high - low) / 2를 꼭 이용해야 함을 잊으면 안된다.

## 10816 - 숫자카드

이 문제는 upperbound와 lowerbound를 직접 구현해보는 연습을 하기위해서 C로 문제를 풀이하였다.

lowerbound는 target이 되는 값보다 가장 늦게 낮은 값이 되는 인덱스를 가리키고 upperbound는 target이 되는 값보다 가장 먼저 높은 값이 되는 인덱스를 가리킨다는 개념만 알고 이를 구현하면 문제를 매우 쉽게 풀이할 수 있고, 음수값과 큰 범위가 있기 때문에 위에서 말한 mid 식을 잘 조정해주어야 한다.

## 11478 - 서로 다른 부분 문자열의 개수

이 문제 또한 set을 사용하지 않으면 시간복잡도의 초과로 틀릴 수 밖에 없다. 이를 빼면 문제가 매우매우 쉽게 때문에 set으로만 담는다는 것만 알면 브론즈 3수준의 문제로 책정된다.