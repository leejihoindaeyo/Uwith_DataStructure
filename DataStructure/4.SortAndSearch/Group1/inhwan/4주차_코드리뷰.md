1번, 10816 숫자카드2 :
  선형탐색으로 처음엔 풀었으나, 익숙한 선형탐색보다는 다른 방식으로 풀어보기 위해 이진탐색을 이용해 풀었다. 딕셔너리를 이용해 해당 원소들의 갯수를 저장하였으며, 이진탐색을 통해 각 카드들의 개수를 가져오게 만들었다.
  과정 :
    카드 입력 -> 각 카드의 갯수 저장 -> 이진탐색으로 입력받은 카드 갯수 호출

2번, 11478 서로다른 부분 문자열의 개수 :
  처음 문제를 보고 이중 반복문을 가장 먼저 떠올렸다. 우선 이중 반복을 통해 i번째부터 j 번째까지의 문자열을 가져와 갯수를 세주었다.

3번, 2512 예산 :
  처음에는 예산에 초과가 되는지 확인후, 초과될경우 이진탐색으로 최댓값을 확인할 생각이었으나, 시간복잡도를 생각해보니 생각보다 많이 차이가 나지 않을거 같아서 이진탐색으로 처음부터 확인하는걸로 바꾸었다.
  우선 0부터 가장 최대값 사이의 중간값을 mid도 정의하여 mid에서 이진탐색을 시작하였다
  과정 :
    mid정의 -> x<mid : sum+=x, x>mid : sum+=mid -> 과정을 start와 end가 서로 바뀌거나 같아질때까지 반복 -> mid 출력

4번, 2002 추월 :
  차번호와 순서를 기억하기 위해 딕셔너리로 in, out 차 저장, 딕셔너리의 key를 이용해 바뀐 차량확인 후 num 숫자 추가
  과정 :
    차 순서 - 번호 딕셔너리 저장 -> in, out 바뀐 차량 확인 -> num 추가

5번, 1092 배 :
  우선 각 리스트를 정렬해주어 무게제한이 높은 크레인이 무거운 박스를 들 수 있도록 만든다. 만든후 첫번째 크레인과 첫번째 박스를 비교하여 못 들경우 -1를 출력한다. 들 수 있다면 모든 박스를 옮길수 있다는 의미이다.
  이후 박스를 옮기기위해 while문을 통해 모든 박스를 옮기도록 만든다. 현재 크레인과 현재 박스를 확인후 못 들경우 다음 박스로 넘어가고 마지막 박스에서는 횟수를 추가하고 처음 크레인으로 돌아오게 만든다. 이 과정을 반복하여 횟수를 계속 추가한다.
  과정 :
    리스트 정렬 -> 예외처리 -> 반복문을 통해 모든 박스 옮기기 -> 들 수 있을경우 크레인 박스 모두 다음으로 넘어감, 못 들경우 횟수 박스만 이동, 마지막 박스에서 횟수 추가