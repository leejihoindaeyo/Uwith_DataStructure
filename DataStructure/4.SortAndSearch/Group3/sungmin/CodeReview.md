# 10816번 숫자 카드 2 
- ***딕셔너리(map)*** 을 사용하는 문제였는데 오랜만에 사용해봐서 그런지 함수나 명령어가 기억이 안나서 조금 찾아보면서 풀엇다.
- ***딕셔너리***의 기본적인 구조를 알면 생각보다 어려운 문제는 아니였던 것 같다.
  
  <br><br>

# 11478번 서로 다른 부분 문자열의 갯수
- ***집합 (set)*** 을 사용하는 문제였는데 코드 길이에서 보이는것 처럼 정말 어려울게 없었다. 
- ***집합***을 이용하면 알아서 중복을 제거해준다는 점 정도가 유용했다.

  <br><br>


# 2512번 예산 
- 문제해결방식을 찾는 것은 정말 어렵지 않았다. 보자마자 ***for***문을 이용해서 한계값을 찾는 방식으로 진행해봤는데 시간초과가 자꾸 떠서 ***이진 탐색***으로 방식을 바꿔서 진행해봤다.
- 문제 해결에서 어려운 부분은 딱히 없고 이진 탐색을 구현하는 코드 정도를 외우면 좋을거라는 생각이 들었다. 
  

``` python
while low <= high:
    mid = (low+high) // 2 
    new_nums = [min(num,mid) for num in nums] 
                # 문제에서 요구하는 조건 

    res = sum(new_nums)
    
    if res <= Maximum :
        result = mid
        low = mid+1
    
    else :
        high = mid -1
        
```

# 2002번 추월
- 솔직히 5문제 중에 가장 어렵게 느껴지는 문제였다. 어떤 상황일때 추월한 상황일지를 판단하는게 가장 어려웠다. 
- 나는 그 부분을 딕셔너리로 해결하기로 하고 ***차량의 이름을 key로 들어온 순서를 value*** 로 지정하여 들어온 순서와 나가는 순서를 비교해서 추월을 판단하는 방식을 사용했다.
  
    <br><br>


# 1092번 배
- 이 문제는 문제 해결 방식은 정말 어려운 부분이 없었다.***그리디 알고리즘***을 이용해서 문제를 해결했다.
- 근데 코드를 제출했을때 자꾸 시간 초과 문제가 발생하여서 코드를 한줄 한줄 수정하는 방식으로 진행했다 정렬을 한 후에 인덱스로 리스트를 관리해서 시간을 줄이고, sys 라이브러리를 사용해서 시간을 줄여주었다. ***pypy3***로 백준에 코드를 제출했더니 시간 부족 문제를 해결할 수 있었다.